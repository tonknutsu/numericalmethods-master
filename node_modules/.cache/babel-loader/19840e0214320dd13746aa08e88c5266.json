{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = matchRoutes;\n\nvar _AsyncUtils = require('./AsyncUtils');\n\nvar _PromiseUtils = require('./PromiseUtils');\n\nvar _PatternUtils = require('./PatternUtils');\n\nvar _routerWarning = require('./routerWarning');\n\nvar _routerWarning2 = _interopRequireDefault(_routerWarning);\n\nvar _RouteUtils = require('./RouteUtils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction getChildRoutes(route, location, paramNames, paramValues, callback) {\n  if (route.childRoutes) {\n    return [null, route.childRoutes];\n  }\n\n  if (!route.getChildRoutes) {\n    return [];\n  }\n\n  var sync = true,\n      result = void 0;\n  var partialNextState = {\n    location: location,\n    params: createParams(paramNames, paramValues)\n  };\n  var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {\n    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);\n\n    if (sync) {\n      result = [error, childRoutes];\n      return;\n    }\n\n    callback(error, childRoutes);\n  });\n  if ((0, _PromiseUtils.isPromise)(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {\n    return callback(null, (0, _RouteUtils.createRoutes)(childRoutes));\n  }, callback);\n  sync = false;\n  return result; // Might be undefined.\n}\n\nfunction getIndexRoute(route, location, paramNames, paramValues, callback) {\n  if (route.indexRoute) {\n    callback(null, route.indexRoute);\n  } else if (route.getIndexRoute) {\n    var partialNextState = {\n      location: location,\n      params: createParams(paramNames, paramValues)\n    };\n    var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {\n      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);\n    });\n    if ((0, _PromiseUtils.isPromise)(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {\n      return callback(null, (0, _RouteUtils.createRoutes)(indexRoute)[0]);\n    }, callback);\n  } else if (route.childRoutes || route.getChildRoutes) {\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n        return;\n      }\n\n      var pathless = childRoutes.filter(function (childRoute) {\n        return !childRoute.path;\n      });\n      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {\n        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {\n          if (error || indexRoute) {\n            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);\n            done(error, routes);\n          } else {\n            next();\n          }\n        });\n      }, function (err, routes) {\n        callback(null, routes);\n      });\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n\nfunction assignParams(params, paramNames, paramValues) {\n  return paramNames.reduce(function (params, paramName, index) {\n    var paramValue = paramValues && paramValues[index];\n\n    if (Array.isArray(params[paramName])) {\n      params[paramName].push(paramValue);\n    } else if (paramName in params) {\n      params[paramName] = [params[paramName], paramValue];\n    } else {\n      params[paramName] = paramValue;\n    }\n\n    return params;\n  }, params);\n}\n\nfunction createParams(paramNames, paramValues) {\n  return assignParams({}, paramNames, paramValues);\n}\n\nfunction matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {\n  var pattern = route.path || '';\n\n  if (pattern.charAt(0) === '/') {\n    remainingPathname = location.pathname;\n    paramNames = [];\n    paramValues = [];\n  } // Only try to match the path if the route actually has a pattern, and if\n  // we're not just searching for potential nested absolute paths.\n\n\n  if (remainingPathname !== null && pattern) {\n    try {\n      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);\n\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n    } catch (error) {\n      callback(error);\n    } // By assumption, pattern is non-empty here, which is the prerequisite for\n    // actually terminating a match.\n\n\n    if (remainingPathname === '') {\n      var match = {\n        routes: [route],\n        params: createParams(paramNames, paramValues)\n      };\n      getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {\n        if (error) {\n          callback(error);\n        } else {\n          if (Array.isArray(indexRoute)) {\n            var _match$routes;\n\n            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {\n              return !route.path;\n            }), 'Index routes should not have paths') : void 0;\n\n            (_match$routes = match.routes).push.apply(_match$routes, indexRoute);\n          } else if (indexRoute) {\n            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;\n            match.routes.push(indexRoute);\n          }\n\n          callback(null, match);\n        }\n      });\n      return;\n    }\n  }\n\n  if (remainingPathname != null || route.childRoutes) {\n    // Either a) this route matched at least some of the path or b)\n    // we don't have to load this route's children asynchronously. In\n    // either case continue checking for matches in the subtree.\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n      } else if (childRoutes) {\n        // Check the child routes to see if any of them match.\n        matchRoutes(childRoutes, location, function (error, match) {\n          if (error) {\n            callback(error);\n          } else if (match) {\n            // A child route matched! Augment the match and pass it up the stack.\n            match.routes.unshift(route);\n            callback(null, match);\n          } else {\n            callback();\n          }\n        }, remainingPathname, paramNames, paramValues);\n      } else {\n        callback();\n      }\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n/**\n * Asynchronously matches the given location to a set of routes and calls\n * callback(error, state) when finished. The state object will have the\n * following properties:\n *\n * - routes       An array of routes that matched, in hierarchical order\n * - params       An object of URL parameters\n *\n * Note: This operation may finish synchronously if no routes have an\n * asynchronous getChildRoutes method.\n */\n\n\nfunction matchRoutes(routes, location, callback, remainingPathname) {\n  var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n\n  if (remainingPathname === undefined) {\n    // TODO: This is a little bit ugly, but it works around a quirk in history\n    // that strips the leading slash from pathnames when using basenames with\n    // trailing slashes.\n    if (location.pathname.charAt(0) !== '/') {\n      location = _extends({}, location, {\n        pathname: '/' + location.pathname\n      });\n    }\n\n    remainingPathname = location.pathname;\n  }\n\n  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {\n    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {\n      if (error || match) {\n        done(error, match);\n      } else {\n        next();\n      }\n    });\n  }, callback);\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/nadol/node_modules/react-router/lib/matchRoutes.js"],"names":["exports","__esModule","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","matchRoutes","_AsyncUtils","require","_PromiseUtils","_PatternUtils","_routerWarning","_routerWarning2","_interopRequireDefault","_RouteUtils","obj","getChildRoutes","route","location","paramNames","paramValues","callback","childRoutes","sync","result","partialNextState","params","createParams","childRoutesReturn","error","createRoutes","isPromise","then","getIndexRoute","indexRoute","indexRoutesReturn","onChildRoutes","pathless","filter","childRoute","path","loopAsync","index","next","done","routes","concat","Array","isArray","err","apply","undefined","assignParams","reduce","paramName","paramValue","push","matchRouteDeep","remainingPathname","pattern","charAt","pathname","matched","matchPattern","match","_match$routes","process","env","NODE_ENV","every","unshift","module"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = matchRoutes;\n\nvar _AsyncUtils = require('./AsyncUtils');\n\nvar _PromiseUtils = require('./PromiseUtils');\n\nvar _PatternUtils = require('./PatternUtils');\n\nvar _routerWarning = require('./routerWarning');\n\nvar _routerWarning2 = _interopRequireDefault(_routerWarning);\n\nvar _RouteUtils = require('./RouteUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getChildRoutes(route, location, paramNames, paramValues, callback) {\n  if (route.childRoutes) {\n    return [null, route.childRoutes];\n  }\n  if (!route.getChildRoutes) {\n    return [];\n  }\n\n  var sync = true,\n      result = void 0;\n\n  var partialNextState = {\n    location: location,\n    params: createParams(paramNames, paramValues)\n  };\n\n  var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {\n    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);\n    if (sync) {\n      result = [error, childRoutes];\n      return;\n    }\n\n    callback(error, childRoutes);\n  });\n\n  if ((0, _PromiseUtils.isPromise)(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {\n    return callback(null, (0, _RouteUtils.createRoutes)(childRoutes));\n  }, callback);\n\n  sync = false;\n  return result; // Might be undefined.\n}\n\nfunction getIndexRoute(route, location, paramNames, paramValues, callback) {\n  if (route.indexRoute) {\n    callback(null, route.indexRoute);\n  } else if (route.getIndexRoute) {\n    var partialNextState = {\n      location: location,\n      params: createParams(paramNames, paramValues)\n    };\n\n    var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {\n      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);\n    });\n\n    if ((0, _PromiseUtils.isPromise)(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {\n      return callback(null, (0, _RouteUtils.createRoutes)(indexRoute)[0]);\n    }, callback);\n  } else if (route.childRoutes || route.getChildRoutes) {\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n        return;\n      }\n\n      var pathless = childRoutes.filter(function (childRoute) {\n        return !childRoute.path;\n      });\n\n      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {\n        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {\n          if (error || indexRoute) {\n            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);\n            done(error, routes);\n          } else {\n            next();\n          }\n        });\n      }, function (err, routes) {\n        callback(null, routes);\n      });\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n\nfunction assignParams(params, paramNames, paramValues) {\n  return paramNames.reduce(function (params, paramName, index) {\n    var paramValue = paramValues && paramValues[index];\n\n    if (Array.isArray(params[paramName])) {\n      params[paramName].push(paramValue);\n    } else if (paramName in params) {\n      params[paramName] = [params[paramName], paramValue];\n    } else {\n      params[paramName] = paramValue;\n    }\n\n    return params;\n  }, params);\n}\n\nfunction createParams(paramNames, paramValues) {\n  return assignParams({}, paramNames, paramValues);\n}\n\nfunction matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {\n  var pattern = route.path || '';\n\n  if (pattern.charAt(0) === '/') {\n    remainingPathname = location.pathname;\n    paramNames = [];\n    paramValues = [];\n  }\n\n  // Only try to match the path if the route actually has a pattern, and if\n  // we're not just searching for potential nested absolute paths.\n  if (remainingPathname !== null && pattern) {\n    try {\n      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n    } catch (error) {\n      callback(error);\n    }\n\n    // By assumption, pattern is non-empty here, which is the prerequisite for\n    // actually terminating a match.\n    if (remainingPathname === '') {\n      var match = {\n        routes: [route],\n        params: createParams(paramNames, paramValues)\n      };\n\n      getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {\n        if (error) {\n          callback(error);\n        } else {\n          if (Array.isArray(indexRoute)) {\n            var _match$routes;\n\n            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {\n              return !route.path;\n            }), 'Index routes should not have paths') : void 0;\n            (_match$routes = match.routes).push.apply(_match$routes, indexRoute);\n          } else if (indexRoute) {\n            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;\n            match.routes.push(indexRoute);\n          }\n\n          callback(null, match);\n        }\n      });\n\n      return;\n    }\n  }\n\n  if (remainingPathname != null || route.childRoutes) {\n    // Either a) this route matched at least some of the path or b)\n    // we don't have to load this route's children asynchronously. In\n    // either case continue checking for matches in the subtree.\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n      } else if (childRoutes) {\n        // Check the child routes to see if any of them match.\n        matchRoutes(childRoutes, location, function (error, match) {\n          if (error) {\n            callback(error);\n          } else if (match) {\n            // A child route matched! Augment the match and pass it up the stack.\n            match.routes.unshift(route);\n            callback(null, match);\n          } else {\n            callback();\n          }\n        }, remainingPathname, paramNames, paramValues);\n      } else {\n        callback();\n      }\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n\n/**\n * Asynchronously matches the given location to a set of routes and calls\n * callback(error, state) when finished. The state object will have the\n * following properties:\n *\n * - routes       An array of routes that matched, in hierarchical order\n * - params       An object of URL parameters\n *\n * Note: This operation may finish synchronously if no routes have an\n * asynchronous getChildRoutes method.\n */\nfunction matchRoutes(routes, location, callback, remainingPathname) {\n  var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n\n  if (remainingPathname === undefined) {\n    // TODO: This is a little bit ugly, but it works around a quirk in history\n    // that strips the leading slash from pathnames when using basenames with\n    // trailing slashes.\n    if (location.pathname.charAt(0) !== '/') {\n      location = _extends({}, location, {\n        pathname: '/' + location.pathname\n      });\n    }\n    remainingPathname = location.pathname;\n  }\n\n  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {\n    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {\n      if (error || match) {\n        done(error, match);\n      } else {\n        next();\n      }\n    });\n  }, callback);\n}\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}