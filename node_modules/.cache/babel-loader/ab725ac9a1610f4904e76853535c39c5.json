{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nimport { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { escape } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nimport { getSafeProperty } from '../../utils/customs';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode =\n/* #__PURE__ */\nfactory(name, dependencies, function (_ref) {\n  var Range = _ref.Range,\n      Node = _ref.Node,\n      size = _ref.size;\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    } // TODO: deprecated since v3, remove some day\n\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');\n    };\n\n    Object.defineProperty(this, 'object', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, _toConsumableArray(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/tonknutsu/Downloads/numericalmethods-master/numericalmethods-master/node_modules/mathjs/es/expression/node/IndexNode.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","isBigNumber","isConstantNode","isNode","isRangeNode","isSymbolNode","map","escape","factory","getSafeProperty","name","dependencies","createIndexNode","_ref","Range","Node","size","IndexNode","dimensions","dotNotation","SyntaxError","every","isObjectProperty","Error","deprecated","defineProperty","get","set","type","isIndexNode","_compile","math","argNames","evalDimensions","range","needsEnd","childArgNames","create","end","evalStart","start","evalEnd","evalStep","step","evalDimension","scope","args","context","s","valueOf","childArgs","createRange","_evalStart","_evalEnd","_evalStep","_childArgNames","evalRange","_evalRange","index","evalIndexNode","apply","forEach","callback","_ifNode","clone","slice","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","toNumber","isClass"],"mappings":"AAAA,SAASA,kBAAT,CAA4BC,GAA5B,EAAiC;AAAE,SAAOC,kBAAkB,CAACD,GAAD,CAAlB,IAA2BE,gBAAgB,CAACF,GAAD,CAA3C,IAAoDG,kBAAkB,EAA7E;AAAkF;;AAErH,SAASA,kBAAT,GAA8B;AAAE,QAAM,IAAIC,SAAJ,CAAc,iDAAd,CAAN;AAAyE;;AAEzG,SAASF,gBAAT,CAA0BG,IAA1B,EAAgC;AAAE,MAAIC,MAAM,CAACC,QAAP,IAAmBC,MAAM,CAACH,IAAD,CAAzB,IAAmCG,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BN,IAA/B,MAAyC,oBAAhF,EAAsG,OAAOO,KAAK,CAACC,IAAN,CAAWR,IAAX,CAAP;AAA0B;;AAElK,SAASJ,kBAAT,CAA4BD,GAA5B,EAAiC;AAAE,MAAIY,KAAK,CAACE,OAAN,CAAcd,GAAd,CAAJ,EAAwB;AAAE,SAAK,IAAIe,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG,IAAIJ,KAAJ,CAAUZ,GAAG,CAACiB,MAAd,CAAvB,EAA8CF,CAAC,GAAGf,GAAG,CAACiB,MAAtD,EAA8DF,CAAC,EAA/D,EAAmE;AAAEC,MAAAA,IAAI,CAACD,CAAD,CAAJ,GAAUf,GAAG,CAACe,CAAD,CAAb;AAAmB;;AAAC,WAAOC,IAAP;AAAc;AAAE;;AAEtK,SAASE,WAAT,EAAsBC,cAAtB,EAAsCC,MAAtC,EAA8CC,WAA9C,EAA2DC,YAA3D,QAA+E,gBAA/E;AACA,SAASC,GAAT,QAAoB,mBAApB;AACA,SAASC,MAAT,QAAuB,oBAAvB;AACA,SAASC,OAAT,QAAwB,qBAAxB;AACA,SAASC,eAAT,QAAgC,qBAAhC;AACA,IAAIC,IAAI,GAAG,WAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,MAAV,EAAkB,MAAlB,CAAnB;AACA,OAAO,IAAIC,eAAe;AAC1B;AACAJ,OAAO,CAACE,IAAD,EAAOC,YAAP,EAAqB,UAAUE,IAAV,EAAgB;AAC1C,MAAIC,KAAK,GAAGD,IAAI,CAACC,KAAjB;AAAA,MACIC,IAAI,GAAGF,IAAI,CAACE,IADhB;AAAA,MAEIC,IAAI,GAAGH,IAAI,CAACG,IAFhB;AAIA;;;;;;;;;;;;;;;;AAeA,WAASC,SAAT,CAAmBC,UAAnB,EAA+BC,WAA/B,EAA4C;AAC1C,QAAI,EAAE,gBAAgBF,SAAlB,CAAJ,EAAkC;AAChC,YAAM,IAAIG,WAAJ,CAAgB,kDAAhB,CAAN;AACD;;AAED,SAAKF,UAAL,GAAkBA,UAAlB;AACA,SAAKC,WAAL,GAAmBA,WAAW,IAAI,KAAlC,CAN0C,CAMD;;AAEzC,QAAI,CAACxB,KAAK,CAACE,OAAN,CAAcqB,UAAd,CAAD,IAA8B,CAACA,UAAU,CAACG,KAAX,CAAiBlB,MAAjB,CAAnC,EAA6D;AAC3D,YAAM,IAAIhB,SAAJ,CAAc,4DAAd,CAAN;AACD;;AAED,QAAI,KAAKgC,WAAL,IAAoB,CAAC,KAAKG,gBAAL,EAAzB,EAAkD;AAChD,YAAM,IAAIC,KAAJ,CAAU,mDAAV,CAAN;AACD,KAdyC,CAcxC;;;AAGF,QAAIC,UAAU,GAAG,SAASA,UAAT,GAAsB;AACrC,YAAM,IAAID,KAAJ,CAAU,uEAAV,CAAN;AACD,KAFD;;AAIAhC,IAAAA,MAAM,CAACkC,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;AACpCC,MAAAA,GAAG,EAAEF,UAD+B;AAEpCG,MAAAA,GAAG,EAAEH;AAF+B,KAAtC;AAID;;AAEDP,EAAAA,SAAS,CAACzB,SAAV,GAAsB,IAAIuB,IAAJ,EAAtB;AACAE,EAAAA,SAAS,CAACzB,SAAV,CAAoBoC,IAApB,GAA2B,WAA3B;AACAX,EAAAA,SAAS,CAACzB,SAAV,CAAoBqC,WAApB,GAAkC,IAAlC;AACA;;;;;;;;;;;;;;AAcAZ,EAAAA,SAAS,CAACzB,SAAV,CAAoBsC,QAApB,GAA+B,UAAUC,IAAV,EAAgBC,QAAhB,EAA0B;AACvD;AACA;AACA;AACA;AACA;AACA,QAAIC,cAAc,GAAG3B,GAAG,CAAC,KAAKY,UAAN,EAAkB,UAAUgB,KAAV,EAAiBpC,CAAjB,EAAoB;AAC5D,UAAIM,WAAW,CAAC8B,KAAD,CAAf,EAAwB;AACtB,YAAIA,KAAK,CAACC,QAAN,EAAJ,EAAsB;AACpB;AACA,cAAIC,aAAa,GAAG7C,MAAM,CAAC8C,MAAP,CAAcL,QAAd,CAApB;AACAI,UAAAA,aAAa,CAACE,GAAd,GAAoB,IAApB;;AAEA,cAAIC,SAAS,GAAGL,KAAK,CAACM,KAAN,CAAYV,QAAZ,CAAqBC,IAArB,EAA2BK,aAA3B,CAAhB;;AAEA,cAAIK,OAAO,GAAGP,KAAK,CAACI,GAAN,CAAUR,QAAV,CAAmBC,IAAnB,EAAyBK,aAAzB,CAAd;;AAEA,cAAIM,QAAQ,GAAGR,KAAK,CAACS,IAAN,GAAaT,KAAK,CAACS,IAAN,CAAWb,QAAX,CAAoBC,IAApB,EAA0BK,aAA1B,CAAb,GAAwD,YAAY;AACjF,mBAAO,CAAP;AACD,WAFD;AAGA,iBAAO,SAASQ,aAAT,CAAuBC,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,gBAAIC,CAAC,GAAGhC,IAAI,CAAC+B,OAAD,CAAJ,CAAcE,OAAd,EAAR;AACA,gBAAIC,SAAS,GAAG3D,MAAM,CAAC8C,MAAP,CAAcS,IAAd,CAAhB;AACAI,YAAAA,SAAS,CAACZ,GAAV,GAAgBU,CAAC,CAAClD,CAAD,CAAjB;AACA,mBAAOqD,WAAW,CAACZ,SAAS,CAACM,KAAD,EAAQK,SAAR,EAAmBH,OAAnB,CAAV,EAAuCN,OAAO,CAACI,KAAD,EAAQK,SAAR,EAAmBH,OAAnB,CAA9C,EAA2EL,QAAQ,CAACG,KAAD,EAAQK,SAAR,EAAmBH,OAAnB,CAAnF,CAAlB;AACD,WALD;AAMD,SAlBD,MAkBO;AACL;AACA,cAAIK,UAAU,GAAGlB,KAAK,CAACM,KAAN,CAAYV,QAAZ,CAAqBC,IAArB,EAA2BC,QAA3B,CAAjB;;AAEA,cAAIqB,QAAQ,GAAGnB,KAAK,CAACI,GAAN,CAAUR,QAAV,CAAmBC,IAAnB,EAAyBC,QAAzB,CAAf;;AAEA,cAAIsB,SAAS,GAAGpB,KAAK,CAACS,IAAN,GAAaT,KAAK,CAACS,IAAN,CAAWb,QAAX,CAAoBC,IAApB,EAA0BC,QAA1B,CAAb,GAAmD,YAAY;AAC7E,mBAAO,CAAP;AACD,WAFD;;AAIA,iBAAO,SAASY,aAAT,CAAuBC,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,mBAAOI,WAAW,CAACC,UAAU,CAACP,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAAX,EAAmCM,QAAQ,CAACR,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAA3C,EAAmEO,SAAS,CAACT,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAA5E,CAAlB;AACD,WAFD;AAGD;AACF,OAjCD,MAiCO,IAAI1C,YAAY,CAAC6B,KAAD,CAAZ,IAAuBA,KAAK,CAACxB,IAAN,KAAe,KAA1C,EAAiD;AACtD;AACA,YAAI6C,cAAc,GAAGhE,MAAM,CAAC8C,MAAP,CAAcL,QAAd,CAArB;;AAEAuB,QAAAA,cAAc,CAACjB,GAAf,GAAqB,IAArB;;AAEA,YAAIkB,SAAS,GAAGtB,KAAK,CAACJ,QAAN,CAAeC,IAAf,EAAqBwB,cAArB,CAAhB;;AAEA,eAAO,SAASX,aAAT,CAAuBC,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,cAAIC,CAAC,GAAGhC,IAAI,CAAC+B,OAAD,CAAJ,CAAcE,OAAd,EAAR;AACA,cAAIC,SAAS,GAAG3D,MAAM,CAAC8C,MAAP,CAAcS,IAAd,CAAhB;AACAI,UAAAA,SAAS,CAACZ,GAAV,GAAgBU,CAAC,CAAClD,CAAD,CAAjB;AACA,iBAAO0D,SAAS,CAACX,KAAD,EAAQK,SAAR,EAAmBH,OAAnB,CAAhB;AACD,SALD;AAMD,OAdM,MAcA;AACL;AACA,YAAIU,UAAU,GAAGvB,KAAK,CAACJ,QAAN,CAAeC,IAAf,EAAqBC,QAArB,CAAjB;;AAEA,eAAO,SAASY,aAAT,CAAuBC,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,iBAAOU,UAAU,CAACZ,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAAjB;AACD,SAFD;AAGD;AACF,KAxDuB,CAAxB;AAyDA,QAAIW,KAAK,GAAGjD,eAAe,CAACsB,IAAD,EAAO,OAAP,CAA3B;AACA,WAAO,SAAS4B,aAAT,CAAuBd,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,UAAI7B,UAAU,GAAGZ,GAAG,CAAC2B,cAAD,EAAiB,UAAUW,aAAV,EAAyB;AAC5D,eAAOA,aAAa,CAACC,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAApB;AACD,OAFmB,CAApB;AAGA,aAAOW,KAAK,CAACE,KAAN,CAAY,KAAK,CAAjB,EAAoB9E,kBAAkB,CAACoC,UAAD,CAAtC,CAAP;AACD,KALD;AAMD,GAtED;AAuEA;;;;;;AAMAD,EAAAA,SAAS,CAACzB,SAAV,CAAoBqE,OAApB,GAA8B,UAAUC,QAAV,EAAoB;AAChD,SAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKoB,UAAL,CAAgBlB,MAApC,EAA4CF,CAAC,EAA7C,EAAiD;AAC/CgE,MAAAA,QAAQ,CAAC,KAAK5C,UAAL,CAAgBpB,CAAhB,CAAD,EAAqB,gBAAgBA,CAAhB,GAAoB,GAAzC,EAA8C,IAA9C,CAAR;AACD;AACF,GAJD;AAKA;;;;;;;;AAQAmB,EAAAA,SAAS,CAACzB,SAAV,CAAoBc,GAApB,GAA0B,UAAUwD,QAAV,EAAoB;AAC5C,QAAI5C,UAAU,GAAG,EAAjB;;AAEA,SAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKoB,UAAL,CAAgBlB,MAApC,EAA4CF,CAAC,EAA7C,EAAiD;AAC/CoB,MAAAA,UAAU,CAACpB,CAAD,CAAV,GAAgB,KAAKiE,OAAL,CAAaD,QAAQ,CAAC,KAAK5C,UAAL,CAAgBpB,CAAhB,CAAD,EAAqB,gBAAgBA,CAAhB,GAAoB,GAAzC,EAA8C,IAA9C,CAArB,CAAhB;AACD;;AAED,WAAO,IAAImB,SAAJ,CAAcC,UAAd,EAA0B,KAAKC,WAA/B,CAAP;AACD,GARD;AASA;;;;;;AAMAF,EAAAA,SAAS,CAACzB,SAAV,CAAoBwE,KAApB,GAA4B,YAAY;AACtC,WAAO,IAAI/C,SAAJ,CAAc,KAAKC,UAAL,CAAgB+C,KAAhB,CAAsB,CAAtB,CAAd,EAAwC,KAAK9C,WAA7C,CAAP;AACD,GAFD;AAGA;;;;;;AAMAF,EAAAA,SAAS,CAACzB,SAAV,CAAoB8B,gBAApB,GAAuC,YAAY;AACjD,WAAO,KAAKJ,UAAL,CAAgBlB,MAAhB,KAA2B,CAA3B,IAAgCE,cAAc,CAAC,KAAKgB,UAAL,CAAgB,CAAhB,CAAD,CAA9C,IAAsE,OAAO,KAAKA,UAAL,CAAgB,CAAhB,EAAmBgD,KAA1B,KAAoC,QAAjH;AACD,GAFD;AAGA;;;;;;;AAOAjD,EAAAA,SAAS,CAACzB,SAAV,CAAoB2E,iBAApB,GAAwC,YAAY;AAClD,WAAO,KAAK7C,gBAAL,KAA0B,KAAKJ,UAAL,CAAgB,CAAhB,EAAmBgD,KAA7C,GAAqD,IAA5D;AACD,GAFD;AAGA;;;;;;;AAOAjD,EAAAA,SAAS,CAACzB,SAAV,CAAoB4E,SAApB,GAAgC,UAAUC,OAAV,EAAmB;AACjD;AACA,WAAO,KAAKlD,WAAL,GAAmB,MAAM,KAAKgD,iBAAL,EAAzB,GAAoD,MAAM,KAAKjD,UAAL,CAAgBoD,IAAhB,CAAqB,IAArB,CAAN,GAAmC,GAA9F;AACD,GAHD;AAIA;;;;;;AAMArD,EAAAA,SAAS,CAACzB,SAAV,CAAoB+E,MAApB,GAA6B,YAAY;AACvC,WAAO;AACLC,MAAAA,MAAM,EAAE,WADH;AAELtD,MAAAA,UAAU,EAAE,KAAKA,UAFZ;AAGLC,MAAAA,WAAW,EAAE,KAAKA;AAHb,KAAP;AAKD,GAND;AAOA;;;;;;;;;AASAF,EAAAA,SAAS,CAACwD,QAAV,GAAqB,UAAUC,IAAV,EAAgB;AACnC,WAAO,IAAIzD,SAAJ,CAAcyD,IAAI,CAACxD,UAAnB,EAA+BwD,IAAI,CAACvD,WAApC,CAAP;AACD,GAFD;AAGA;;;;;;;AAOAF,EAAAA,SAAS,CAACzB,SAAV,CAAoBmF,MAApB,GAA6B,UAAUN,OAAV,EAAmB;AAC9C;AACA,QAAInD,UAAU,GAAG,EAAjB;;AAEA,SAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKoB,UAAL,CAAgBlB,MAApC,EAA4CF,CAAC,EAA7C,EAAiD;AAC/CoB,MAAAA,UAAU,CAACpB,CAAD,CAAV,GAAgB,KAAKoB,UAAL,CAAgBpB,CAAhB,EAAmB6E,MAAnB,EAAhB;AACD;;AAED,QAAI,KAAKxD,WAAT,EAAsB;AACpB,aAAO,gEAAgE,0CAAhE,GAA6GZ,MAAM,CAAC,KAAK4D,iBAAL,EAAD,CAAnH,GAAgJ,SAAvJ;AACD,KAFD,MAEO;AACL,aAAO,oEAAoEjD,UAAU,CAACoD,IAAX,CAAgB,uCAAhB,CAApE,GAA+H,iEAAtI;AACD;AACF,GAbD;AAcA;;;;;;;AAOArD,EAAAA,SAAS,CAACzB,SAAV,CAAoBoF,MAApB,GAA6B,UAAUP,OAAV,EAAmB;AAC9C,QAAInD,UAAU,GAAG,KAAKA,UAAL,CAAgBZ,GAAhB,CAAoB,UAAU4B,KAAV,EAAiB;AACpD,aAAOA,KAAK,CAAC2C,KAAN,CAAYR,OAAZ,CAAP;AACD,KAFgB,CAAjB;AAGA,WAAO,KAAKlD,WAAL,GAAmB,MAAM,KAAKgD,iBAAL,EAAN,GAAiC,EAApD,GAAyD,OAAOjD,UAAU,CAACoD,IAAX,CAAgB,GAAhB,CAAP,GAA8B,GAA9F;AACD,GALD,CA/P0C,CAoQvC;;;AAGH,WAASnB,WAAT,CAAqBX,KAArB,EAA4BF,GAA5B,EAAiCK,IAAjC,EAAuC;AACrC,WAAO,IAAI7B,KAAJ,CAAUb,WAAW,CAACuC,KAAD,CAAX,GAAqBA,KAAK,CAACsC,QAAN,EAArB,GAAwCtC,KAAlD,EAAyDvC,WAAW,CAACqC,GAAD,CAAX,GAAmBA,GAAG,CAACwC,QAAJ,EAAnB,GAAoCxC,GAA7F,EAAkGrC,WAAW,CAAC0C,IAAD,CAAX,GAAoBA,IAAI,CAACmC,QAAL,EAApB,GAAsCnC,IAAxI,CAAP;AACD;;AAED,SAAO1B,SAAP;AACD,CA5QM,EA4QJ;AACD8D,EAAAA,OAAO,EAAE,IADR;AAED5E,EAAAA,MAAM,EAAE;AAFP,CA5QI,CAFA","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nimport { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { escape } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nimport { getSafeProperty } from '../../utils/customs';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode =\n/* #__PURE__ */\nfactory(name, dependencies, function (_ref) {\n  var Range = _ref.Range,\n      Node = _ref.Node,\n      size = _ref.size;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    } // TODO: deprecated since v3, remove some day\n\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');\n    };\n\n    Object.defineProperty(this, 'object', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, _toConsumableArray(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}